#include <Arduino.h>

// ===============================================================
//                       Mode Switching Logic
// ===============================================================

// Enum to define the robot's primary operational modes
enum RobotMode {
  WALL_FOLLOWING,
  LINE_FOLLOWING
};

// Global variable to hold the current mode, starts in line-following
RobotMode currentMode = LINE_FOLLOWING; 


// ===============================================================
//                  Declarations from Both Programs
// ===============================================================

// --- Mode Switching Declarations (FIX) ---
void checkAndSetMode();
bool isHardLeft(uint8_t m);
bool isHardRight(uint8_t m);
uint8_t readSensorsMask(); 
void executeWallFollowing();
void executeLineFollowing();

// --- Wall Follower Declarations ---
void stopMotors();
long readUltrasonic(int trigPin, int echoPin);
void countEncoderL();
void countEncoderR();
void smoothTurnLeft();
void smoothTurnRight();
void moveForward(int pwmValR, int pwmValL);
void moveBackward(int pwmVal);
void pivotLeft(int pwmVal);
void pivotRight(int pwmVal);
void pivot180(int pwmVal);
void moveForwardDistance(int distance_cm, int pwmVal);

// --- Line Follower Declarations ---
void setMotorSpeeds(int leftPWM, int rightPWM);
bool computePosition(float &posOut);
void turnLeft90();
void turnRight90();


// ===============================================================
//                       Pin Definitions
// ===============================================================

// --- Wall Follower Pins (Ultrasonic) ---
#define TRIG_FRONT 48
#define ECHO_FRONT 49
#define TRIG_RIGHT 50
#define ECHO_RIGHT 51
#define TRIG_LEFT  52
#define ECHO_LEFT  53

// --- Motor Driver Pins (Shared) ---
#define L_RPWM 4
#define L_LPWM 5
#define L_REN  6
#define L_LEN  7

#define R_RPWM 2
#define R_LPWM 3
#define R_REN  9
#define R_LEN  8

// --- Encoder Pins (From Wall Follower) ---
#define L_ENC_A 18
#define L_ENC_B 19
#define R_ENC_A 20
#define R_ENC_B 21

// --- Line Follower Pins (Reflectance Array) ---
const uint8_t sensorPins[8] = {22, 23, 24, 25, 26, 27, 28, 29};


// ===============================================================
//                      Constants & Globals
// ===============================================================

// --- Wall Follower Constants ---
const float WHEEL_DIAMETER_CM = 6.5f;
const float WHEEL_BASE_CM     = 17.0f;
const int pulsesPerMotorRev = 11;
const int gearRatio         = 20;
const int countsPerRev      = pulsesPerMotorRev * gearRatio * 2;
const int   TURN_PWM       = 50;
const float TURN_RADIUS_CM = 10.0f;
const int   PIVOT_180_PWM  = 55;
const int OBSTACLE_THRESHOLD      = 12;
const int OPEN_SPACE_THRESHOLD_CM = 50;
const int DEAD_END_THRESHOLD      = 12;
const int NO_WALL_THRESHOLD       = 30;
const int CORNER_CLEARANCE_CM     = 5;
const int   BASE_PWM_STRAIGHT = 60;
const float Kp_wall           = 1.5f; // Renamed to avoid conflict
const int   MAX_CORRECTION    = 20;
const int   WALL_DETECT_RANGE = 25;
const int ALIGN_PWM         = 45;
const int ALIGN_DURATION_MS = 50;
const int ALIGN_TOLERANCE_CM= 1;
volatile long encoderCountL = 0;
volatile long encoderCountR = 0;

// --- Line Follower Constants ---
float Kp_line = 10.0f; // Renamed
float Ki = 0.0f;
float Kd_line = 4.0f; // Renamed
int   baseSpeed = 60;
int   maxPWM    = 100;
int   maxCorr   = 20;
float emaAlpha  = 0.25f;
float err = 0, errEMA = 0, lastPos = 0;
float integ = 0;
enum LFState { FOLLOW, HARD_LEFT, HARD_RIGHT, SEARCH };
LFState lineFollowState = FOLLOW;
int   turnPWM_line   = 100; // Renamed
int   reacquireCount = 3;
int   lineLostSpinMs = 15;
bool  lastWasLeft    = false;

// Helpers
inline void stopRight(){ analogWrite(R_RPWM, 0); analogWrite(R_LPWM, 0); }
inline void stopLeft() { analogWrite(L_RPWM, 0); analogWrite(L_LPWM, 0); }
inline long absl(long x){ return (x < 0) ? -x : x; }
static inline int clamp(int v, int lo, int hi){ return (v<lo)?lo: (v>hi)?hi: v; }


// ===============================================================
//                          SETUP
// ===============================================================
void setup() {
  Serial.begin(9600);

  // --- Pin Initializations ---
  // Ultrasonic
  pinMode(TRIG_FRONT, OUTPUT); pinMode(ECHO_FRONT, INPUT);
  pinMode(TRIG_LEFT,  OUTPUT); pinMode(ECHO_LEFT,  INPUT);
  pinMode(TRIG_RIGHT, OUTPUT); pinMode(ECHO_RIGHT, INPUT);

  // Motors
  pinMode(R_RPWM, OUTPUT); pinMode(R_LPWM, OUTPUT);
  pinMode(L_RPWM, OUTPUT); pinMode(L_LPWM, OUTPUT);
  pinMode(R_REN, OUTPUT);  pinMode(R_LEN, OUTPUT);
  pinMode(L_REN, OUTPUT);  pinMode(L_LEN, OUTPUT);
  digitalWrite(R_REN, HIGH); digitalWrite(R_LEN, HIGH);
  digitalWrite(L_REN, HIGH); digitalWrite(L_LEN, HIGH);

  // Encoders
  pinMode(L_ENC_A, INPUT_PULLUP); pinMode(L_ENC_B, INPUT_PULLUP);
  pinMode(R_ENC_A, INPUT_PULLUP); pinMode(R_ENC_B, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(L_ENC_A), countEncoderL, CHANGE);
  attachInterrupt(digitalPinToInterrupt(R_ENC_A), countEncoderR, CHANGE);

  // Reflectance Sensor Array
  for (int i=0; i<8; i++) pinMode(sensorPins[i], INPUT);

  stopMotors();
  Serial.println("Robot Initialized. Starting in Line Following Mode.");
}

// ===============================================================
//                          MAIN LOOP
// ===============================================================
void loop() {
  // Step 1: Check the ground surface to determine the mode
  checkAndSetMode();

  // Step 2: Execute the logic for the current mode
  switch (currentMode) {
    case WALL_FOLLOWING:
      executeWallFollowing();
      break;
    case LINE_FOLLOWING:
      executeLineFollowing();
      break;
  }
  
  delay(10); // Small delay for stability
}

// ===============================================================
//          MODE DETECTION & EXECUTION LOGIC
// ===============================================================

/*
 * Reads the reflectance sensor array to decide the operational mode.
 * - If all sensors see black, switch to WALL_FOLLOWING.
 * - Otherwise, assume a line course and switch to LINE_FOLLOWING.
 */
void checkAndSetMode() {
  uint8_t sensorMask = readSensorsMask();

  // If all 8 sensors are on a black surface, switch to wall following
  if (sensorMask == 0b11111111) {
    if (currentMode != WALL_FOLLOWING) {
      Serial.println(">> ALL BLACK DETECTED: Switching to WALL FOLLOWING mode.");
      currentMode = WALL_FOLLOWING;
      stopMotors(); // Stop motors briefly during transition
      delay(200);
    }
  } 
  // Otherwise, we are on a course with a line (or all white)
  else {
    if (currentMode != LINE_FOLLOWING) {
      Serial.println(">> LINE/WHITE DETECTED: Switching to LINE FOLLOWING mode.");
      currentMode = LINE_FOLLOWING;
      stopMotors(); // Stop motors briefly during transition
      delay(200);
    }
  }
}

/**
 * This function contains the original loop() content from the
 * WALL-FOLLOWING program.
 */
void executeWallFollowing() {
  long dFront = readUltrasonic(TRIG_FRONT, ECHO_FRONT);
  long dLeft  = readUltrasonic(TRIG_LEFT,  ECHO_LEFT);
  long dRight = readUltrasonic(TRIG_RIGHT, ECHO_RIGHT);

  bool frontValid = dFront > 0;
  bool leftValid  = dLeft  > 0;
  bool rightValid = dRight > 0;

  Serial.print("WALL MODE | F:"); Serial.print(dFront);
  Serial.print(" L:"); Serial.print(dLeft);
  Serial.print(" R:"); Serial.println(dRight);

  // STATE 1: Dead End
  if (frontValid && dFront < DEAD_END_THRESHOLD &&
      leftValid  && dLeft  < DEAD_END_THRESHOLD &&
      rightValid && dRight < DEAD_END_THRESHOLD) {
      Serial.println("--- DEAD END: Executing 180 turn ---");
      stopMotors(); delay(200);
      pivot180(PIVOT_180_PWM);
      stopMotors(); delay(200);
  }
  // STATE 2: Obstacle ahead
  else if (frontValid && dFront < OBSTACLE_THRESHOLD) {
    stopMotors(); delay(150);
    bool turnLeft = (dLeft > dRight);
    if (turnLeft) smoothTurnLeft();
    else          smoothTurnRight();
    stopMotors(); delay(150);
  }
  // STATE 3: No wall on the left, turn left
  else if (leftValid && dLeft > NO_WALL_THRESHOLD) {
    Serial.println("--- No left wall. Clearing corner... ---");
    moveForwardDistance(CORNER_CLEARANCE_CM, BASE_PWM_STRAIGHT);
    Serial.println("--- Corner cleared. Initiating left turn. ---");
    stopMotors(); delay(10);
    smoothTurnLeft();
    stopMotors(); delay(150);
  }
  // STATE 4: Path clear (wall following)
  else {
    int leftSpeed, rightSpeed;
    if (leftValid && dLeft < 10) {
      int targetDist = 6;
      int error = (int)(dLeft - targetDist);
      int correction = (int)(Kp_wall * error);
      correction = constrain(correction, -MAX_CORRECTION, MAX_CORRECTION);
      leftSpeed  = constrain(BASE_PWM_STRAIGHT + correction, 0, 100);
      rightSpeed = constrain(BASE_PWM_STRAIGHT - correction, 0, 100);
    } else {
      leftSpeed = BASE_PWM_STRAIGHT;
      rightSpeed = BASE_PWM_STRAIGHT;
    }
    moveForward(rightSpeed, leftSpeed);
  }
}

/**
 * This function contains the original loop() content from the
 * LINE-FOLLOWING program.
 */
void executeLineFollowing() {
  uint8_t m = readSensorsMask();
  Serial.print("LINE MODE | Mask: "); Serial.println(m, BIN);

  if (m == 0){
    lineFollowState = SEARCH;
  } else {
    if (isHardLeft(m)) {
      lineFollowState = HARD_LEFT;
      lastWasLeft = true;
    } else if (isHardRight(m)) {
      lineFollowState = HARD_RIGHT;
      lastWasLeft = false;
    } else {
      lineFollowState = FOLLOW;
    }
  }

  switch (lineFollowState){
    case FOLLOW: {
      float pos;
      if (!computePosition(pos)){
        lineFollowState = SEARCH;
        break;
      }
      float posEMA = errEMA*(1.0f-emaAlpha) + pos*emaAlpha;
      float dpos   = posEMA - lastPos;
      lastPos = posEMA;
      err = -posEMA;
      errEMA = errEMA*(1.0f-emaAlpha) + err*emaAlpha;
      integ += errEMA;
      integ  = clamp(integ, -1000, 1000);
      float u  = Kp_line*errEMA + Ki*integ - Kd_line*dpos;
      int   du = (int)clamp((int)u, -maxCorr, maxCorr);
      int left  = clamp(baseSpeed + du, 0, maxPWM);
      int right = clamp(baseSpeed - du, 0, maxPWM);
      setMotorSpeeds(left, right);
      break;
    }
    case HARD_LEFT: {
      turnLeft90();
      lineFollowState = FOLLOW;
      setMotorSpeeds(baseSpeed, baseSpeed);
      delay(60);
      break;
    }
    case HARD_RIGHT: {
      turnRight90();
      lineFollowState = FOLLOW;
      setMotorSpeeds(baseSpeed, baseSpeed);
      delay(60);
      break;
    }
    case SEARCH: {
      if (lastWasLeft) pivotLeft(turnPWM_line);
      else pivotRight(turnPWM_line);
      delay(lineLostSpinMs);
      stopMotors();
      delay(5);
      uint8_t mm = readSensorsMask();
      if ((mm & (1<<3)) || (mm & (1<<4))) lineFollowState = FOLLOW;
      break;
    }
  }
}


// ===============================================================
//             FUNCTIONS from WALL FOLLOWER
// ===============================================================

void moveForwardDistance(int distance_cm, int pwmVal) {
  const float wheelCircumference = PI * WHEEL_DIAMETER_CM;
  const long targetCounts = (long)(((float)distance_cm / wheelCircumference) * countsPerRev);
  noInterrupts();
  encoderCountL = 0;
  encoderCountR = 0;
  interrupts();
  moveForward(pwmVal, pwmVal);
  while (true) {
    noInterrupts();
    long currentL = encoderCountL;
    long currentR = encoderCountR;
    interrupts();
    if ((absl(currentL) + absl(currentR)) / 2 >= targetCounts) break;
    delay(10);
  }
  stopMotors();
}

void pivot180(int pwmVal) {
  const float wheelCircumference = PI * WHEEL_DIAMETER_CM;
  const float turnDistance = PI * (WHEEL_BASE_CM / 2.0f);
  const long targetCounts = (long)((turnDistance / wheelCircumference) * countsPerRev);
  encoderCountL = 0;
  encoderCountR = 0;
  pivotRight(pwmVal);
  while(absl(encoderCountL) < targetCounts || absl(encoderCountR) < targetCounts) {
    if (absl(encoderCountL) >= targetCounts) stopLeft();
    if (absl(encoderCountR) >= targetCounts) stopRight();
    delay(5);
  }
  stopMotors();
}

static void smoothTurnArc90(bool leftTurn, float Rc_cm, int pwmOuterMax) {
  const float B = WHEEL_BASE_CM;
  const float R_inner = Rc_cm - (B / 2.0f);
  const float R_outer = Rc_cm + (B / 2.0f);
  if (R_inner <= 0.5f) {
    if (leftTurn) pivotLeft(pwmOuterMax); else pivotRight(pwmOuterMax);
    delay(220); stopMotors(); return;
  }
  const float wheelC  = PI * WHEEL_DIAMETER_CM;
  const float s_inner = (PI * R_inner) / 2.0f;
  const float s_outer = (PI * R_outer) / 2.0f;
  const long cnt_inner = (long)((s_inner / wheelC) * countsPerRev);
  const long cnt_outer = (long)((s_outer / wheelC) * countsPerRev);
  int pwmOuter = pwmOuterMax;
  int pwmInner = (int)((float)pwmOuterMax * (s_inner / s_outer));
  encoderCountL = 0; encoderCountR = 0;
  if (leftTurn) {
    analogWrite(L_RPWM, 0); analogWrite(L_LPWM, pwmInner);
    analogWrite(R_RPWM, pwmOuter); analogWrite(R_LPWM, 0);
  } else {
    analogWrite(R_RPWM, pwmInner); analogWrite(R_LPWM, 0);
    analogWrite(L_RPWM, 0); analogWrite(L_LPWM, pwmOuter);
  }
  while (true) {
    long aL = absl(encoderCountL); long aR = absl(encoderCountR);
    long tgtL = leftTurn ? cnt_inner : cnt_outer;
    long tgtR = leftTurn ? cnt_outer : cnt_inner;
    if ((aL >= tgtL) && (aR >= tgtR)) break;
    delay(5);
  }
  stopMotors();
}

void smoothTurnLeft()  { smoothTurnArc90(true,  TURN_RADIUS_CM, TURN_PWM); }
void smoothTurnRight() { smoothTurnArc90(false, TURN_RADIUS_CM, TURN_PWM); }

void moveForward(int pwmValR, int pwmValL) {
  analogWrite(R_RPWM, pwmValR); analogWrite(R_LPWM, 0);
  analogWrite(L_RPWM, 0);       analogWrite(L_LPWM, pwmValL);
}

void moveBackward(int pwmVal) {
  analogWrite(R_RPWM, 0);       analogWrite(R_LPWM, pwmVal);
  analogWrite(L_RPWM, pwmVal);  analogWrite(L_LPWM, 0);
}

void pivotLeft(int pwmVal) {
  analogWrite(R_RPWM, pwmVal); analogWrite(R_LPWM, 0);
  analogWrite(L_RPWM, pwmVal); analogWrite(L_LPWM, 0);
}

void pivotRight(int pwmVal) {
  analogWrite(L_RPWM, 0);      analogWrite(L_LPWM, pwmVal);
  analogWrite(R_RPWM, 0);      analogWrite(R_LPWM, pwmVal);
}

long readUltrasonic(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH); delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH, 25000);
  return (duration == 0) ? -1 : (duration * 0.034 / 2);
}

void countEncoderL() {
  if (digitalRead(L_ENC_A) == digitalRead(L_ENC_B)) encoderCountL++; else encoderCountL--;
}

void countEncoderR() {
  if (digitalRead(R_ENC_A) == digitalRead(R_ENC_B)) encoderCountR--; else encoderCountR++;
}

// ===============================================================
//             FUNCTIONS from LINE FOLLOWER
// ===============================================================

void stopMotors(){
  analogWrite(R_RPWM, 0); analogWrite(R_LPWM, 0);
  analogWrite(L_RPWM, 0); analogWrite(L_LPWM, 0);
}

void setMotorSpeeds(int leftPWM, int rightPWM){
  leftPWM  = clamp(leftPWM,  0, 255);
  rightPWM = clamp(rightPWM, 0, 255);
  analogWrite(R_RPWM, rightPWM); analogWrite(R_LPWM, 0); // Right forward
  analogWrite(L_RPWM, 0);        analogWrite(L_LPWM, leftPWM);  // Left forward
}

uint8_t readSensorsMask(){
  uint8_t mask = 0;
  for(int i=0; i<8; i++){
    if (digitalRead(sensorPins[i]) == HIGH) mask |= (1 << i);
  }
  return mask;
}

bool computePosition(float &posOut){
  static const float W[8] = {-3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5};
  uint8_t m = readSensorsMask();
  float num = 0.0f, den = 0.0f;
  for(int i=0; i<8; i++){
    if ((m >> i) & 1){ num += W[i]; den += 1.0f; }
  }
  if (den <= 0.0f) return false;
  posOut = num / den;
  return true;
}

bool isHardLeft(uint8_t m){
  return ((m & 0b00000111) != 0) && !((m & (1<<3)) || (m & (1<<4))) && ((m & 0b11100000) == 0);
}

bool isHardRight(uint8_t m){
  return ((m & 0b11100000) != 0) && !((m & (1<<3)) || (m & (1<<4))) && ((m & 0b00000111) == 0);
}

void turnLeft90(){
  int okCount = 0;
  uint32_t watchdog = millis() + 1500;
  while (millis() < watchdog){
    pivotLeft(turnPWM_line);
    uint8_t m = readSensorsMask();
    if ((m & (1<<3)) || (m & (1<<4))) { if (++okCount >= reacquireCount) break; }
    else okCount = 0;
    delay(5);
  }
  stopMotors(); delay(60);
}

void turnRight90(){
  int okCount = 0;
  uint32_t watchdog = millis() + 1500;
  while (millis() < watchdog){
    pivotRight(turnPWM_line);
    uint8_t m = readSensorsMask();
    if ((m & (1<<3)) || (m & (1<<4))) { if (++okCount >= reacquireCount) break; }
    else okCount = 0;
    delay(5);
  }
  stopMotors(); delay(60);
}
